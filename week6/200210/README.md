## DFS, BFS

* 그래프의 표현: 인접 행렬, 인접 리스트, 해시 테이블

  

## 다익스트라 알고리즘

* DFS, BFS는 가중치가 없는 균일 그래프에서 최단 경로를 계산할 때 쓰임
* 다익스트라는 가중 그래프에서 최단 거리를 계산할 때 쓰임
* 다익스트라는 모든 가중치가 양수일 때만 쓰임(음수라면 벨만-포드 알고리즘 사용)
* One to All(한 노드에서 다른 모든 노드로)

* 우선순위 큐를 사용하지 않는다면 시간복잡도는 O(N^2)이다.
  * (최솟값을 찾을 때 N 반복) * (출발점에서 N-1번 반복)
  * 특히 정점의 개수만큼 반복하므로, 정점의 개수는 많은데 간선의 개수가 적다면 매우 비효율적



예제:

[[백준] 1238. 파티]([https://github.com/SeungYoungOh/algorithm_study/blob/master/week6/200210/SeungYoung/%5B%EB%B0%B1%EC%A4%80%5D%201238.%20%ED%8C%8C%ED%8B%B0.md](https://github.com/SeungYoungOh/algorithm_study/blob/master/week6/200210/SeungYoung/[백준] 1238. 파티.md))

우선순위 큐를 안 쓰고 방문 리스트를 만드는 경우 내가 했던 고민은, **"특정 노드를 방문했다고 체크하는 방식은, 아직 특정 노드로 가는 더 짧은 루트가 있음에도 그 루트를 스킵할 수도 있지 않을까?"** 였다.

* 즉, 아래에서 start -> a -> fin이 빠름에도, start -> b -> fin 으로 간 뒤 방문 리스트를 체크하지 않나 싶었다.

  따져보면 그럴 수 없는 것이, 

  1. 방문했음을 체크하려면 현재 가중치들(dist) 중 그 노드까지 가는 거리가 최단이어야 한다.
2. 만약 start -> b -> fin 보다 짧은 루트 start -> x -> fin 이 존재한다면, start -> x 는 적어도 start -> b -> fin 보다 짧을 것이다. 
  3. 즉, 방문했다는 것의 선행 조건은 "지금까지 이동한 경로의 가중치보다 작은 경로가 없다" 이므로 최단 경로가 생략될 수 없다.
  
  ```mermaid
stateDiagram
  start --> a : 4
  start --> b : 3
  
  a --> fin: 1
  b --> fin: 3
  
  start --> c: 8
  ```
  
  

  



